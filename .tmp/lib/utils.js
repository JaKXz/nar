// Generated by LiveScript 1.2.0
var fs, hu, path, crypto, status, os, rm, mk, findup, normalize, join, basename, delimiter, env, platform, exit, nextTick, arch, _;
fs = require('fs');
hu = require('hu');
path = require('path');
crypto = require('crypto');
status = require('./status');
os = require('os-shim');
rm = require('rimraf').sync;
mk = require('mkdirp').sync;
findup = require('findup-sync');
normalize = path.normalize, join = path.join, basename = path.basename, delimiter = path.delimiter;
env = process.env, platform = process.platform, exit = process.exit, nextTick = process.nextTick, arch = process.arch;
module.exports = _ = {
  path: path,
  platform: platform,
  arch: arch,
  extend: hu.extend,
  vals: hu.vals,
  EOL: os.EOL,
  clone: hu.clone,
  isObject: hu.isObject,
  isArray: hu.isArray,
  isString: hu.isString,
  mk: mk,
  rm: rm,
  delimiter: delimiter,
  has: hu.has,
  echo: function(){
    return console.log.apply(this, arguments);
  },
  next: nextTick,
  env: function(it){
    return env[it] || null;
  },
  now: function(){
    return new Date().getTime();
  },
  isWin: platform === 'win32',
  toKb: function(it){
    if (it) {
      return Math.round(it / 1024);
    } else {
      return 0;
    }
  },
  exists: function(it){
    return it && fs.existsSync(
    normalize(
    it));
  },
  stringify: function(it){
    if (it) {
      return JSON.stringify(it, null, 2);
    }
  },
  keys: function(it){
    if (hu.isObject(
    it)) {
      return Object.keys(
      it);
    } else {
      return [];
    }
  },
  tmpdir: function(name){
    name == null && (name = 'pkg');
    return join(os.tmpdir(), "nar-" + name + "-" + _.random());
  },
  addExtension: function(it){
    if (it && !_.isUrl(
    it)) {
      if (!/.nar$/.test(it)) {
        it += '.nar';
      }
    }
    return it;
  },
  isDir: function(it){
    return _.exists(
    it) && fs.lstatSync(
    normalize(
    it)).isDirectory();
  },
  isFile: function(it){
    return _.exists(
    it) && fs.lstatSync(
    normalize(
    it)).isFile();
  },
  random: function(){
    return _.now() + Math.floor(Math.random() * 10000);
  },
  lines: function(it){
    if (it) {
      return it.split(os.EOL);
    }
  },
  isUrl: function(it){
    return /^http[s]?\:/.test(
    it);
  },
  httpStatus: function(code){
    if (code) {
      return code + " " + (status[code] || '');
    } else {
      return '';
    }
  },
  replaceEnvVars: function(str){
    return str.replace(/\$\{(\w+)\}/ig, function(_, name){
      return process.env[name] || '';
    });
  },
  exit: function(code){
    if (code === 0 || !code) {
      exit(
      code);
    }
    return function(message){
      if (message != null) {
        if (String.prototype.red != null) {
          message = message.red;
        }
        _.echo(
        message);
      }
      return exit(
      code);
    };
  },
  read: function(it){
    var data;
    if (_.exists(
    it)) {
      data = fs.readFileSync(
      normalize(
      it)).toString();
      if (/.json$/.test(
      it)) {
        return JSON.parse(
        data);
      } else {
        return data;
      }
    } else {
      return null;
    }
  },
  write: function(path, data){
    if (path) {
      return fs.writeFileSync(path, data);
    }
  },
  once: function(cb){
    var error;
    error = false;
    return function(it){
      if (!error) {
        cb.apply(this, arguments);
      }
      if (it) {
        return error = true;
      }
    };
  },
  discoverPkg: function(dir){
    dir == null && (dir = process.cwd());
    return findup('package.json', {
      cwd: dir
    });
  },
  archiveName: function(nar){
    var name, version;
    name = '';
    if (nar) {
      name += nar.name || 'unnamed';
      if (version = nar.manifest.version) {
        name += "-" + version;
      }
      if (nar.binary) {
        name += "-" + platform + "-" + arch;
      }
    }
    return name + ".nar";
  },
  checksum: function(file, cb){
    var hash;
    hash = crypto.createHash('sha1');
    return fs.createReadStream(
    file).on('data', (function(it){
      return hash.update(it);
    })).on('end', function(){
      return cb(null, hash.digest('hex'));
    }).on('error', cb);
  },
  copy: function(file, dest, cb){
    var filename;
    filename = basename(
    file);
    dest = join(dest, filename);
    return fs.createReadStream(
    file).pipe(fs.createWriteStream(dest)).on('close', function(){
      return cb(null, dest);
    }).on('error', cb);
  }
};
